name: Push NuGet from Release

on:
  workflow_call:
    inputs:
      private-repo:
        type: boolean
        default: false
    secrets:
      NUGET_API_KEY:
        required: true

jobs:
  Release-NuGet-Packages:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET Core
        if: ${{ inputs.private-repo }}        
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          source-url: ${{ vars.AZURE_ARTIFACTS_FEED_USER }}
        env:
          NUGET_AUTH_TOKEN: ${{ secrets.AZURE_DEVOPS_TOKEN }} 

      - name: Download release assets
        run: gh release download ${{ github.event.release.tag_name }} --dir ./artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Strip build number, update nuspec, rezip, and tag git
        id: rename
        shell: pwsh
        env:
          GITHUB_PRERELEASE: ${{ github.event.release.prerelease }}
        run: |
          $artifacts = Get-ChildItem -Path ./artifacts -File | Where-Object { $_.Name -match '\.(s|)nupkg$' }
          if (-not $artifacts) { Write-Error "No packages found in ./artifacts"; exit 1 }
      
          $suffix = if ($env:GITHUB_PRERELEASE -eq 'true') { '-beta' } else { '' }
          $newTag = $null
      
          # Track renamed internal packages
          $renamedPackages = @{}
          
          foreach ($pkg in $artifacts) {
            Write-Host "Processing $($pkg.Name)..."
          
            if ($pkg.Name -notmatch '(.*?)(\d+\.\d+\.\d+)\.\d+(\..*)') {
              Write-Warning "Skipping file (pattern mismatch): $($pkg.Name)"
              continue
            }
          
            $prefix = $matches[1]
            $majorMinorPatch = $matches[2]
            $ext = $matches[3]
            if (-not $newTag) { $newTag = $majorMinorPatch }
          
            $packageId = ($prefix.TrimEnd('.')).Split('.')[-1]
            $pkgName = $prefix.TrimEnd('.')
            $newVersion = "$majorMinorPatch$suffix"
          
            # Store this mapping for dependency fix later
            $renamedPackages["$pkgName"] = $newVersion
          
            # Unpack, edit, rezip
            $work = Join-Path $pkg.DirectoryName ([IO.Path]::GetFileNameWithoutExtension($pkg.Name))
            if (Test-Path $work) { Remove-Item $work -Recurse -Force }
            New-Item -ItemType Directory -Path $work | Out-Null
          
            Expand-Archive -Path $pkg.FullName -DestinationPath $work -Force
            Remove-Item $pkg.FullName -Force
          
            $nuspec = Get-ChildItem $work -Filter *.nuspec | Select-Object -First 1
            [xml]$xml = Get-Content $nuspec.FullName
            $xml.package.metadata.version = ($xml.package.metadata.version -replace '-preview\.\d+', $suffix)
          
            # Save now, we'll adjust dependencies later
            $xml.Save($nuspec.FullName)
          
            $outName = "$prefix$majorMinorPatch$($suffix)$ext"
            $dest = Join-Path $pkg.DirectoryName $outName
            if (Test-Path $dest) { Remove-Item $dest -Force }
            Compress-Archive -Path (Join-Path $work '*') -DestinationPath $dest -Force
            Remove-Item $work -Recurse -Force
          }
          
          # Update dependency versions across all renamed packages
          foreach ($pkgPath in Get-ChildItem ./artifacts -Filter *.nupkg -File) {
            $work = Join-Path $pkgPath.DirectoryName ([IO.Path]::GetFileNameWithoutExtension($pkgPath.Name))
            if (Test-Path $work) { Remove-Item $work -Recurse -Force }
            New-Item -ItemType Directory -Path $work | Out-Null
            Expand-Archive -Path $pkgPath.FullName -DestinationPath $work -Force
            Remove-Item $pkgPath.FullName -Force
          
            $nuspec = Get-ChildItem $work -Filter *.nuspec | Select-Object -First 1
            [xml]$xml = Get-Content $nuspec.FullName
          
            foreach ($dep in $xml.package.metadata.dependencies.dependency) {
              $depId = $dep.id
              if ($renamedPackages.ContainsKey($depId)) {
                $oldVersion = $dep.version
                $dep.version = $renamedPackages[$depId]
                Write-Host "Updated dependency $depId: $oldVersion -> $($dep.version)"
              }
            }
          
            $xml.Save($nuspec.FullName)
            Compress-Archive -Path (Join-Path $work '*') -DestinationPath $pkgPath.FullName -Force
            Remove-Item $work -Recurse -Force
          }
      
          if (-not $newTag) { Write-Error "Could not determine version tag"; exit 1 }
      
          "VERSION_TAG=$newTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Repacked packages, updated nuspec, stripped build numbers. Version tag: $newTag"
      
          # Git tag
          git tag $newTag
          git push origin $newTag

      - name: Push to NuGet.org
        if: ${{ !inputs.private-repo }}
        run: |
          dotnet nuget push "./artifacts/*.nupkg" \
          --source https://api.nuget.org/v3/index.json \
          --api-key ${{ secrets.NUGET_API_KEY }}

      - name: Push to Azure
        if: ${{ inputs.private-repo }}
        run: |
          dotnet nuget push "./artifacts/*.nupkg" \
          --source source ${{ vars.AZURE_ARTIFACTS_FEED_URL }} \
          --api-key AzureDevOps

      - name: Update release with renamed packages
        uses: ncipollo/release-action@v1
        with:
          tag: "${{ github.event.release.tag_name }}"
          artifacts: "./artifacts/*.*"
          draft: false
          makeLatest: ${{ github.event.release.prerelease == false }}
          allowUpdates: true
          removeArtifacts: true
          updateOnlyUnreleased: false
          generateReleaseNotes: true
          name: "${{ steps.rename.outputs.VERSION_TAG }}"

      - name: Delete previous draft releases
        uses: hugo19941994/delete-draft-releases@v1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
